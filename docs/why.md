One might reasonably ask, with the existence of ZooKeeper ("ZK") and etcd, why someone would spend their time on another consensus & coordination system. This is a note to explain our thinking.

To be very clear, we are fans of both ZK and etcd. Both of those systems have excellent people working on them, and they both serve rightly as critical components for many workloads. That doesn't mean that there's no room left for another piece of software in the same category that has slightly different goals and priorities.

One of the top priorities in developing haret is ease of operation. We have experience in the past delivering software intended for lights-out operation, and we intend to bring lessons from that experience to bear in making haret a software system that can be confidently operated as "invisible infrastructure" in many cases.

Some of the use cases for coordination systems that we have run across were in environments where, for reasons beyond the authors' control, a heavy (or even perceived to be heavy) runtime such as the JVM was not allowed. For those workloads, ZK was not an option.

Similarly, in the local use cases for systems like this that we have seen, there is a strong desire for clients to be available and simple to integrate and use across multiple languages and runtimes. A simple, well-documented client protocol allowing for relatively thin and easy client libraries is a basic requirement in our context.

Some deployment scenarios require an independent coordination namespace for each running instance of a given software system. (e.g. that software may use a certain well-known path name for internal discovery) With some existing choices, this means operating a full separate cluster of the coordination system for each of those, even if the capacity would otherwise have been more easily managed as a single cluster. For this reason, we designed the notion of separate namespaces into haret so that there can be many "top level" data sets that it maintains.

We should point out that not everything we describe here is something that we see as a lack or a failing in other similar systems. We are less focused on that point of view and more focused on understanding our own priorities.

There are also some features not in the initial use case requirements, but that we wish to see in a system like this ourselves. A primary example here is to have rich and appropriate primitives for synchronization. While a linearized hierarchical key/value store can be an adequate base for coordination in a larger distributed system if you have nothing else, we believe that it will serve software authors better to give them a system with out-of-the-box support for more useful and richer primitives supported directly by their coordination system. Not all of these have yet been built in to haret, but we have done our work so far with those in mind, structured to enable developing more powerful distributed coordination primitives inside the system.

We happen to have used Viewstamped Replication as the consensus protocol in haret. However, unlike some other coordination systems, we have kept assumptions about the specific protocol isolated from both the client-facing and data storage parts of the system. This comes with a few interesting benefits. Of most immediate value to us is that it allows for easier testing and analysis of our protocol implementation, not mixed up with other system concerns. We could also swap out VSR for a different protocol (as long as it provided linearizability) if there was a reason to do so. This might allow for a true apples-to-apples performance comparison of consensus protocols against a given workload, for example. We also look forward to incorporating some of the possibilities opened by the Flexible Paxos concept to enable different performance and availability tradeoffs, and we see this decoupling of the consensus algorithm as beneficial to such future work.

Performance, particularly latency when under load, is very much a goal of haret. However, we make no particular promises about such matters at this early time. We are focused on making the system usable and operable first, while not erecting any obstacles to later performance improvements.

We have no desire to compete against or "win" in the space of coordination systems. Rather, we hope to collaborate and to work with the wider community in order to jointly improve the state of the art and provide appropriate choices for different needs.
