V2R2 Introduction
=================

V2R2 is software for providing a distributed service built on proven protocols that exposes strongly consistent coordination primitives via an easy to use API, in order to satisfy the essential common dependencies of many distributed applications. 

V2R2 is portable and can be run on Linux, Mac or ESX. V2R2 provides an easy to consume API to allow for thin client libraries that can be written in most popular programming languages. 

V2R2 allows for multi tenancy such that the same hardware pool can be used to serve multiple isolated independent API namespaces.

This documents covers the details for V2R2. 

 
Nomenclature
=============

- **Namespace** :
A hierarchal collection of elements 

- **Element** : Namespace is composed of elements, each element has a name and can contain data/value. Elements can have parent child relations between them creating a hierarchy. 

- **Node** :
A instantiated process running V2R2 server side code.

- **Node ID** :
A unique ID generated by V2R2 for each instance/process of the server side code.

- **Client ID** :
Each client is stamped with a unique Client ID. This is a combination of a fixed client instance ID and a per session ID.

- **Replication group** :
A sorted set of V2R2 nodes that hosts the replicated copies of a V2R2 namespace.

- **Replica** :
A node in a replication group.

- **Primary** :
The node in the replication group that is selected to serve requests modifying the V2R2 namespace.

- **Backups** :
The nodes in the replication group that are not the primary are called backups.

- **Configuration**:
The configuration for V2R2 is split into separate entities that are managed independently. Each public configuration key is annotated with the type.

	- **Replication group configuration set** :
	The configuration that is only common to all replicas in the replication group and is 	managed by the primary.
	
	- **Global Configuration** :
	Configuration that is common across all nodes.	
	- **Instance specific configuration** :
	Configuration that is specific to a node.
	
	- **Namespace specific configuration** :
	Configuration that is specific to a namespace that is served by a replication group.
	
- **Reconfiguration** :
Reconfiguration is used to describe the process of changing the membership of the replication group.

- **Epoch** :
Each change to the replication group is ordered and tagged with a monotonically increasing Epoc number. 

- **VSN** :
Each selection of a primary in a replication group is ordered and tagged with a **V**iew **S**equence **N**umber. VSN is monotonically increasing within an EPOC

- **LSN** :
Each request received by the primary has a **L**og **S**equence **N**umber assigned. LSN is monotonically increasing for a VSN

- **CSN** :
Requests originating from a client are ordered and tagged with a  **C**lient **S**equence **N**umber. CSN are monotonically increasing.

- **VDS** :
Each server node in V2R2 runs a **V**2R2 **D**iscovery **S**ervice. Clients can query VDS to get current status of V2R2. This includes the replication group information for a specific namespace for a tenant. VDS is eventually consistent.


Namespace and Namespace API
=============================

V2R2 provides a hierarchical namespace that is created by the applications consuming V2R2 APIs. 

## Namespace Element types

The namespace is composed of the following types of elements

* Root : The root of the namespace. Contains the core attributes for the namespace. The root also stores the namespace wide configuration entries. The root only supports the APIs to create/move/delete namespace entries and setting/getting configuration entries.

* Binary Elements: These are elements to which a client can attach a binary blob of data in addition to setting common attributes.

* Structured Element: The data attached to this element is understood by V2R2 and V2R2 provides APIs for operations native to the structured type. Element structure types are of the following types.
	* List : Element contains a list 
	* Set : Element contains a set. 
	* Queues : Element contains a queue.

Both Structured and Binary elements can also be of types

* Ephemeral : Elements that will be deleted after the session with client ends. Ephemeral nodes do not have child elements. Ephemeral nodes can only be the leaf level/bottom most elements in the namespace. By default elements are non-ephemeral.

* Sequential : Ephemeral and Non-ephemeral nodes can also be set to be type sequential. A monotonically increasing sequence number is appended to each element name.

V2R2 provides ability for clients to synchronize on any element type.  

The core attributes common to all the element types are

* Client time stamp 
	* create 
	* last update
* Server time stamp 
	* create 
	* last update
* Client ID 
	* create
	* last update
* Version: The combination of Epoch, View number and LSN is the version of an element. 
	* Version for create.
	* Version for last update.
* Type of element
* List of child elements

Optional attributes

* Synchronization attributes
	* Current set of client IDs owning a resource. For mutexes, the max set size is 1.
	* List of client IDs waiting.
	
## ACL

V2R2 integrates with lightwave and enforces ACLs for administration and access to namespaces and their elements. 

ACLs are applied on a per element basis and are a subset of the ACL checks possible in a POSIX filesystem. There are no path based ACL checks. 

*More details to be added post demo*
	
## Mutable vs non mutable APIs

APIs tagged mutable can only be executed on the primary. Requests not marked as mutable can be executed on any replica but for strong consistency they should be executed on the primary. To execute requests on replicas they must include the optional STALEREAD flag.

	v2r2> GET /myroot/<path>/mykey STALEREAD


## Sessions and Heartbeating

Certain APIs require a session. Sessions once established must be renewed via heart-beating with the primary. Sessions are against a replication group and will failover, if the failover is completed in a timely manner.

A session starts automatically when a request needing a session is sent to the primary.  After the request is completed the client must continue to hearbeat for the duration the session is needed. The following are the techniques to heartbeat.

* Repeating the session based request with the original CSN.  
* Performing any other operation against the primary with the Client ID used to execute the API that requires heart-beating.

The default duration for timeout for heart-beating is an attribute of the root and can be changed for each element. 

	v2r2> CONFIG GET /myroot NAMESPACE.SESSION.HEARTBEAT.DURATION
	v2r2> CONFIG SET /myroot NAMESPACE.SESSION.HEARTBEAT.DURATION 3 seconds

Heart-beating is sensitive to the accuracy of clocks and stalling on the client or primary. 


## API

*This is the proposed list of APIs to be supported by V2R2. This is not the final list*

--
### CREATENAMESPACE : Create Namespace
======================================

Creates a namespace within a replication group. An element of type root with the name for the namespace is created with no child elements. The assigned ID for the namespace is expected to be unique within a V2R2 instance.

If the element already exists the response will be EXISTS and no updates will occur. 

#### Parameters 
* Element Name

#### Optional 
* Binary data

#### On Failure
The element is not created and an appropriate error is returned.

#### On Timeout 
The client should retry the request with the original CSN.

#### Tags 
Mutable, atomic.

#### Example

	v2r2> CREATENAMESPACE /mynamespace "Binary Data: Namespace create for demo"
	OK	
	v2r2> CREATENAMESPACE /mynamespace "Binary Data: Namespace create for demo"
	EXISTS

--
### CREATE : Create an element
=======================

Creates an element in the namespace with the specified type and name. The element name is unique within a parent element. 

Create is a parent element level operation and the attributes of the parent will be updated.

If the element already exists the response will be EXISTS and no updates will occur. 

#### Parameters 
* Path including the element name
* Type: BINARY LIST QUEUE SET

#### Optional
* Binary or structured data.

#### On Failure 
The element is not created and an appropriate error is returned.

#### On Timeout
The client should retry the request with the original CSN.

#### Tags 
Mutable, atomic

#### Example

	v2r2> CREATE BINARY EPHEMERAL SEQUENTIAL /myroot/app/element "Binary data to be attached"
	OK
	v2r2> CREATE BINARY /myroot/app/element "Duplicate Name"
	EXISTS

--
### DELETE : Delete an element
==============================

Deletes an element from the namespace. If the element does not exists ERROR\_DOES\_NOT_EXISTS is returned. 

Delete is an parent element level operation and the parent attributes are updated.

#### Parameters
* Path for the element

#### On Failure 
The element is not deleted. 

#### On Timeout 
The client should retry the request with the original CSN. If the operation had succeeded before the retry an OK response is sent for the retry but this does not imply that the namespace path does not exists at the end of the request since it might have been re-created by another client request.

#### Tags
Mutable, atomic

--
### MOVE : Move an element
==========================

Moves an element from one parent element to another. If the target name already exists an NAME\_CONFLICT error is returned. If the FORCE\_MOVE flag is set the target element and all children under it will be deleted and replaced with the source element. 

Move is an operation at the parent element level and does not impact the attributes of the child elements. The attributes for the parent are updated. 

#### Parameters
* Source path
* Target path

#### Flags
FORCE\_MOVE

#### On Failure 
The element is not moved.

#### On Timeout 
The client should retry the request with the original CSN. If the previous operation was completed, no further changes will be made an OK response is sent. 

#### Tags 
Mutable, atomic

--
### GET : Get the element 
=========================

Get the attributes and optionally data  attached to an element. 

#### Parameters
* Element path

#### Optional Parameters
* Get Attributes includes CAS: ATTR
* Get compare and swap tag: CAS


#### Tags
Non Mutable.

#### Example
	v2r2> GET /mynamespace/app/data/record 
	"These are not the doors"
	v2r2> GET /mynamespace/app/data/record CAS
	CAS: 01:10:121323
	"These are not the doors"

--
### PUT : Put data and/or attributes 
====================================

Put the data attached to an element. The entire data is overwritten. The attributes of the element are updated as well. PUT also supports compare and swap (CAS).  

#### Parameters
* Element path.
* Binary data.

#### Optional Parameters
* CAS tag

#### On Failure 
The the data is not updated.

#### On Timeout 
The client should retry the request with the original CSN. If the request was previously completed the data is not updated.

#### Tags 
Mutable, idempotent, atomic.

#### Example

	v2r2> PUT /mynamespace/app/data/record "They open like this" CAS 01:10:121323
	OK

--
### LIST: List elements
=======================

Gets the names of all child elements of a parent element. The response can be paginated with a token that should be used to resume listing. There is no consistency guarantees for the list if the response needs to be paginated, elements could have been deleted or created in between paginations and they might or might not be in the list.

The response is ordered by name. 

#### Parameters 
* Parent element path

#### Optional parameter 
* Token to resume list enumeration

#### On Timeout 
The client should retry the request. 

#### Tags
Non-mutable

#### Example
	v2r2> LIST /mynamespace/app/data/
	TOKEN: 3248927429
	aaa
	aab
	v2r2> LIST /mynamespace/app/data/ TOKEN 3248927429
	TOKEN: 23489729
	aac
	aad
	abc

	

--
### LOOKUP: Lookup path
=======================

Returns true if all the elements in the path exists. If part of the path exists the part of the path that exists is returned. If the entire path exists an OK response is returned.

#### Parameters 
* Path

#### Tags 
Non mutable

#### Example
	v2r2> LOOKUP /mynamespace/app/data/record 
	OK
	v2r2> LOOKUP /mynamespace/app/data/foo
	NOTFOUND
	/mynamespace/app/data


--
### SUBSCRIBE : Subscribe to an element
=======================================

Subscribes to updates that occur to an element. The following modes are supported

* Get notification on updates : Only the meta information for the update is sent. 
* Get notification on updates and the corresponding element : The meta information for the update and the latest element is sent back to the client.

When an application subscribes to updates a minimum number of updates are preserved (CONFIG GET <path to element> SUBS.MIN.HISTORY). The default is set at the root level and can be overridden for each element.

### Stop subscription to element

### Resume subscription to element

For each update there is a corresponding LSN. If a client is disconnection from the replication group it can connect back and resume from the LSN last received.

--
### Synchronization

V2R2 provides numerous APIs to assist synchronization. Any element in the namespace can be used. Only one syncronization primitive can be used on a element at a time. 

--
#### LOCK : Lock a part of the namespace 
============================

There are multiple types of locking supported between nodes

* Read and write locks
* Group locks

For any locking operation the client must have write permission on the element. All child elements inherit the lock and are applied for all operations arriving after the lock request is served. Locking is enforced at the server (locking is not advisory). A session with a lock GRANTED will be able to make progress on requests other clients will get a LOCKED return status with relevant bits about the contention.

Read/Write Locks: By default each lock is a write lock unless specified as a read lock. When a read lock is held on an element, clients holding the lock can send read requests. If a read request is held the write request is completed with PENDING status, the client will then be notifiied of the grant, for this the client needs to keep a session active. The client must then retry the lock request and it will be granted if it processed by the server before the session expires. Once a write lock is held no other requests on different sessions will be allowed. Locking is tied to a session and the vailidity of the lock is dependent on the session being alive. Locks are re-entrant, non re-entrant behavior must be implemented on the client side, primarily cause the server ties the lock to a session and not a request. 

If the element is ephemeral, it will be present as long as there is a client pending on the element.

##### Exmaple
	v2r2> LOCK READ /mynamespace/app/data/resource 
	PENDING
	...
	RETRY
	v2r2> LOCK READ /mynamespace/app/data/resource
	OK
	v2r2>
	
Group Locks: Group locking is to have a all or nothing locking on multiple elements. 

##### Example
	v2r2> LOCK READ GROUP /mynamespace/app/data/alice /mynamespace/app/data/bob 
	PENDING
	/mynamespace/app/data/alice LOCKED
	..
	RETRY
	v2r2> LOCK READ GROUP /mynamespace/app/data/alice /mynamespace/app/data/bob 
	OK

--
#### SEMAPHORE 
===============

Semaphores allow fixed number of clients to acquire them. A client needs to setup the semaphore on an element in the namespace. If the element is ephemeral, it will be present as long as there is a client pending on the element. If there are clients pending on the semaphore the DESTROY operation will complete once the last client has released or it's session expires. The status can be checked via the syncronization attributes using the GET request.

##### Example
	v2r2> SEMAPHORE INIT 3  /mynamespace/app/data/resource
	OK
	v2r2> SEMAPHORE ACQUIRE /mynamespace/app/data/resource
	PENDING
	...
	RETRY
	v2r2> SEMAPHORE ACQUIRE /mynamespace/app/data/resource
	OK
	v2r2> SEMAPHORE RELEASE /mynamespace/app/data/resource
	OK
	v2r2> SEMAPHORE DESTROY /mynamespace/app/data/resource
	PENDING

--
#### Barriers
=============

Barriers are used to allow clients synchronize execution. A client needs to setup the barrier on an element in the namespace. If the element is ephemeral, it will be present as long as there are clients waiting on it. A notification is sent when the barrier can be entered and the clients should retry the request. The last client session to have been established on the barrier will get GO instead of OK as the return status. After sending the return status the barrier goes back to the state it was after init for the next set of clients to wait on it. After the successful return status for wait is sent the session used by the client is no longer relevant for the barrier itself. 

##### Exmaple
	v2r2> BARRIER INIT 4 /mynamespace/app/data/resource
	OK
	v2r2> BARRIER WAIT /mynamespace/app/data/resource
	PENDING
	...
	RETRY
	v2r2> BARRIER WAIT /mynamespace/app/data/resource
	GO
	v2r2> BARRIER DESTROY /mynamespace/app/data/resource

--
### Elect Leader
================

Locking API can be used to elect a leader. The server will notify the next client in line after the leader gives up or it's session expires.

--
### Element Data Types
======================

--
#### Queues
===========

--
#### Sets
=========

--
#### Lists
==========
--
### COUNTER
============

V2R2 provides idempotent counters. If the same request comes more than once but reuses the same CSN the counter will be incremented only once or by the amount specified in the request. Count can go negative. Counter values are 64 bit by default but can be set to 2048 bits. All counters start at 0. By default counters stay at their maximum and minimum values unless told to WRAP.

#### Parameters
* Operations:
	* INC - increment
	* INC <count> - increment by count. counter = counter + count.
	* DEC - decrement
	* DEC <count> - decrement by count. counter = counter - decrement. 
	* RESET - reset to 0
* CREATE 
	* BIT <bitsize> - Set the bitsize after create
	* UNSIGNED - Unsigned counter. Will stay at 0 if drecement goes below 0.
	* WRAP - Counter will wrap for unsigned and unsigned. 

#### Exmaple
	v2r2> CREATE COUNTER /mynamespace/app/data/counter
	OK
	v2r2> CREATE COUNTER UNSIGNED BIT 2048 /mynamespace/app/data/unsigned
	OK
	v2r2> COUNTER INC /mynamespace/app/data/unsigned
	1
	v2r2> COUNTER DEC /mynamespace/app/data/unsigned
	0
	v2r2> COUNTER DEC /mynamespace/app/data/unsigned
	0
	NOWRAP
	v2r2> COUNTER INC /mynamespace/app/data/counter
	1
	v2r2> COUNTER DEC /mynamespace/app/data/counter
	0
	v2r2> COUNTER INC 13 /mynamespace/app/data/counter
	13
	v2r2> COUNTER INC 13 /mynamespace/app/data/counter
	26
	v2r2> COUNTER RESET /mynamespace/app/data/counter
	0
	

--
#### Group Operations/Transactions
==================================

A set of operations can be batched into one group and executed as an atomic unit. 
*More details post demo*

## Admin APIs


# V2R2 Wire Protocol

V2R2 Wire Protocol for clients is simple, fast and human readable, inspired from [Redis' RESP][3]. It supports pipelining with in order processing of requests. The wire protocol is not intended to be compatible with Redis though some commands and operations might be.


# V2R2 and View-stamped Replication

V2R2's core replication within a replication group is based on [view-stamped replication][1]. V2R2 replicates the namespace and its state changes by applying an identical order of incoming requests on all replicas. 

This section only deals with the replication group. V2R2 consists of multiple replication groups that share the same common pool of resources.

## V2R2 Replication Group

V2R2 within it's replication group uses viewstamped replication to replicate the state between a primary and its backups.

[Viewstamped replication (VR)][1] is a distributed algorithm for implementing [state machine based replication] [2] and is analogous to consensus algorithms to achieve replication. In addition to specifying the algorithm for replication, VR also covers reconfiguration of the replication group, sync up of nodes that are behind and potential optimizations that can be implemented without violating correctness.

This document will only cover sufficient details to explain how V2R2 will use VR.

## Guarantees

For a replication group the following guarantees are provided for client operations.

- V2R2 namespace is strongly consistent for all operations performed on the primary.
Operations performed on the backups will see causal consistency but potentially stale state.

- Updates that reach quorum will survive failures, as long as the failures are within the maximum number of failures supported by a replication group.

- Correctness of the V2R2 will remain independent of local or relative wall clocks in a replication group.

- V2R2 will use quorum intersection to preserve the committed writes and will need 2f + 1 nodes for f failures with a minimum size of replication group being 3.

## Replica States

Each node in the replication group can belong to one of the following states.

- **Initialization** : The node is not part of any replication group.

- **Normal** : The node is part of a replication group and is actively participating in the replication of state. A normal node can be a primary or a backup.

- **Recovery** : The node is part of a replication group but not in a normal state.

- **ViewChange** : The nodes are in the process of completing a view change operation (Explained below).

- **Reconfiguration** : The replication group nodes are in reconfiguration state when the membership of the replication group is being changed.

## Initial Bootstrap

1. A V2R2 node starts of only knowing its own IP and port. 

2. The admin API for joining a V2R2 cluster is sent to the V2R2 node, it includes IP and Port of one or more of existing V2R2 nodes. 

3. The Replication Group configuration is passed in via the Admin API to one or more of the nodes. (All nodes are aware and eventually update configuration for all replication groups).

4. The nodes participating in the replication group initiate a view change with view number 0. The view change will be initiated only if more than 2 nodes are present in a replication group.

5. A primary is confirmed and the view change is over. In the initial view change the recovery is a no-op. The V2R2 nodes are in normal state.

6. The primary starts accepting requests on the IP:Port for the replication group. 

7. The client is seeded with the IP:Port of one or more of the V2R2 nodes and the client discovers the primary for the replication group and starts request processing.

## Normal Operation

### Request processing

1. Each request or a batch of requests that changes the state of the namespace is added to the log.
	1. Each request in the log is tagged with Epoch:VSN:LSN:ClientID:CSN

2. Each request that does not change state is batched with other reads and waits for an quorum check. V2R2 will not be using leases to enable reads on the primary without checking state of the quorum. This is primarily done to avoid issues with correctness of leases w.r.t. local timestamps.

### Namespace snapshots

Snapshots of the namespace server multiple purposes:
- Enabling truncation of the log on the primary
- In recovery state by backups to speed up recovery
- During reconfiguration for state transfer

Periodically the primary initiates a snapshot which is viewed as a change to the state of the namespace and is replicated via the log. Older snapshots that are known to have been replicated and now not needed are cleaned up.

Snapshots are identified with a combination of 
		
		SnapshotNumber + Hash(snapshot) 

## Failure Handling

There are various failures that can occur within a replication group.

### Failure to get quorum

The primary depends on being the only primary in a replication group to maintain the semantics of the requests it processes. 

If the primary is unable to get quorum responses, it will initiate a view change to demote itself from being a primary and re-establish a primary and the status of the log. 

### Missed writes 

If a backup notices missing writes in the log, it will demote itself to be in recovery state where it is not part of the quorum that responds to the primary for new entries in the log.

### Primary Failure

V2R2 follows the viewstamp change protocol of VR.

### Timeout semantics

If a primary notices a quorum failure due to timeouts it should initiate a view change and stop processing any more requests.

If a client sees a timeout, it should retry the request with the same CSN. The timeout could be the result of a transient failure or reflect a failure in the replication group. The primary may have been demoted to a backup after a view change and will respond with the details of the new primary. Optionally the client can query for the primary before retrying. 

## Join and leave
A node can join or leave a replication group, initiated by the administration APIs. VR specifies the reconfiguration process but requires request processing to be stopped during the reconfiguration. We are looking into using Rambo in conjunction with VR to allow for request processing to continue during reconfiguration. 

## Implementation optimizations

### Batching

Quorum acknowledgement can be done for a batch of request that have been received during the time duration that the previous quorum acknowledgement was being executed. VR covers batching as an optimization.

### Quorum Check on Reads

For a batch of reads V2R2 can issue a single quorum check message that will insure the causal correctness of read and insure that the read is consistent. During the read processing it is possible in a async distributed system that a new primary is selected but from a correctness stand point this should not violate guarantees.   

## Client sequence numbers

Each client must use a monotonically increasing CSN. The CSN only need to be unique within a TCP session. When the client re-establishes a TCP connection it can restart the monotonically increasing counter.

# V2R2 Administration

V2R2 instance manages multiple replication groups each serving one instance of the namespace. Nodes in the cluster auto join and wait to join a replication group.

# Open questions

## In memory and persistence model for V2R2

The following items are topics that we have not yet closed on entirely but have some indication of where we will head (indicated by => implying tending to)

* Should V2R2 allow swapping in of namespace from disk if it does not fit in memory => yes
* Should V2R2 allow arbitrarily large element names => no
* Should V2R2 allow arbitrarily long paths in namespace => yes
* Should V2R2 allow arbitrarily large data attached to elements => no
* Should all updates be persisted to disk/journal, total failure of a replication group does not imply data loss => opinions?

# Operational Model
## Configuration Management
## Deployment and Bootstrap
## Change Management

# Server Architecture

V2R2 server is layered

# V2R2 project details

V2R2 repo is hosted on github and is currently set to private. 

## Timeline
* July End:
	* This document will be in Beta
* Aug Mid:
	* The basic cluster startup and configuration is to be in place.
* Aug End:
	* The framework for V2R2 replication group and it's communication is to be in place
* Sept End:
	* V2R2 Replication Group is to be functional with basic failure handling
* Oct Mid:
	* Preparing for Demo
* Oct End:
	* Demo

## Testing

* Unit testing is done via [quickcheck][5]
* System testing is to be done via [jepsen] [6]
* ESX testing will be done via Nimbus

## Code developement

Starting August mid, V2R2 will run 2 week sprints with end to end user stories. All single node APIs should be tested with [quickcheck][5]. The failure testing will be manual at least upto September end. If the project is on time for demo, any additional time will be spent on getting a jepsen setup going and being part of every checkin's testing (manual if not automated).

Other code development points
* A loose coding guideline by Aug end. Rust is evolving and coding guidelines are evolving as well. Based on initial experience the team will come up with what it thinks is good rust code
* Initially the entire code will be tested on ESX weekly and post demo each checkin will be tested on ESX.


# 9P FS

V2R2 API subset can also be consumed via exposing the namespace via 9P FS.  *More updates post demo*


<!-- References -->
[1]: pmg.csail.mit.edu/papers/vr-revisited.pdf "Viewstamped Replication Revisited"
[2]: https://www.cs.cornell.edu/fbs/publications/SMSurvey.pdf "Implementing fault-tolerant services using the state machine approach: a tutorial"
[3]: http://redis.io/topics/protocol "Redis Resp"
[4]: http://rd.springer.com/chapter/10.1007/3-540-36108-1_12#page-1 "RAMBO: A reconfigurable atomic memory service for dynamic networks"
[5]: https://github.com/BurntSushi/quickcheck "QuickCheck"
[6]: https://github.com/aphyr/jepsen "Jepsen"


	 